#! /usr/bin/env bash

# the other commands will eventually be subsumed into this command

# search for '####' in libsnap.sh to see environment and coding conventions
source libsnap.sh || exit 1
# We use these constants from libsnap.sh (and change $our_name)
readonly our_path
# We use libsnap.sh variables: file_for_logging log_msg_prefix
# We use these functions from libsnap.sh
readonly -f abort abort-function abort-with-action-Usage
readonly -f set-FS_label--from-mount_dir set-FS_type--from-path
readonly -f merged-continuation-lines need-cmds

for dir in ~/etc /usr/local/etc /etc
    do	config_dir=$dir/$our_name
	[[ -d $config_dir ]] && break
done; readonly config_dir
source $config_dir/configure.sh || abort "missing configure.sh"
readonly udev_rules_file=$config_dir/drives.rules
[[ -s $udev_rules_file ]] || abort "need non-empty $udev_rules_file"

# this sets common_mount_options, extN_mount_options, xfs_mount_options
source  /etc/snapback/configure.sh &> /dev/null # optional

# udev may not provide much of a PATH: https://unix.stackexchange.com/a/99073
PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

Usage="\
Usage: $our_name [options] action [args]

  Current actions are:

     list-drives: show all encrypted drives.

     status name: show detailed status of encrypted drive.

     init [-s sector-size] name device: setup encryption. -s defaults to 4KB;
        find the device with: ls -lt /dev/sd[a-z]*

     rule name device: print a udevd rule to open the device

     open [-r|-M] { mount-dir device | all }: run 'cryptsetup open' on device,
	using FS_label (derived from mount-dir) as name; then mount
	the decrypted device.  If mount-dir is not an absolute path,
	call 'snapback' to get the mount-dir.  [This action is run from
	a udev rule in $config_dir/drives.rules .]
	Use -r to mount readonly, -M to not mount.

     close [-f] {mount-dir|all}: unmap drive (cryptsetup close) & park heads.
         If mount-dir is not an absolute path, call 'snapback' to figure out
	 what to do (if 'max' or 'all', choose busiest backup);
	 'eject' is a synonym for 'close'.
	 Use -f to close even without any good snapshots (e.g. maintenance).

     unmap [-f] {mount-dir|all}: like 'close', but don't park disk heads.

     Common options:
	-d: Debug shell script (don't run commands, just show them): simulation
	-t: Trace shell script (show commands as they execute)
	-h: show this Help message
"

IfRun= Trace= trace_opt= debug_opt=
our_opts=
while getopts "d t hk" arg
    do	our_opts+="-$arg ${OPTARG-} "
	case $arg in
	   ( d ) IfRun=echo     debug_opt=-d ;; # $IfRun prevents side-effects
	   ( t ) Trace="set -x" trace_opt=-t ;;
	   (h|k) print-or-egrep-Usage-then-exit "$@" ;;
	   ( * ) abort "$Usage" ;;
	esac
done
let OPTIND=$OPTIND-1
shift $OPTIND
unset arg

[[ $Trace && $debug_opt ]] && IfRun=:

need-cmds cryptsetup fuser

##############################################################################
# functions
##############################################################################

function set-serial_number() {
	local raw_dev=${1%%[0-9]*}

	serial_number=$(udevadm info $raw_dev |
			    sed -n 's/.*SERIAL_SHORT=//p')
	[[ $serial_number ]]
}

# ----------------------

list-drives() {

	local raw_dev
	for raw_dev in /dev/sd[a-z]*
	    do	sudo cryptsetup isLuks $raw_dev || continue

		set-serial_number $raw_dev || { echo "? $raw_dev"; continue; }

		set -- $(merged-continuation-lines $udev_rules_file |
			     sed -n "/\b$serial_number\b/s/%k.*//p")
		[[ $# != 0 ]] || { echo "? $raw_dev"; continue; }
		local drive=${!#}

		if [[ $drive == /* ]]
		   then local mount_dir=$drive
		   else local mount_dir=${drive_dir_prefix-}$drive
		fi
		set-FS_label--from-mount_dir $mount_dir
		local  dev=/dev/mapper/$FS_label    dm=
		[[ -b $dev ]] && set-absolute_path $dev &&
		    dm="\t# mapped device is $dev -> $absolute_path"

		echo -e "$drive $raw_dev$dm"
	done | sort
}

# ----------------------------------------------------------------------------
# functions for action 'rule'
# ----------------------------------------------------------------------------

readonly rule_format='
# udev puts the basename of the raw-device (which matched KERNEL) into %%k
ACTION=="add", KERNEL=="sd*[!0-9]", ATTRS{serial}=="%s", \
   RUN+="/usr/local/sbin/snapcrypt %s %%k'

print-rule() {
	local name=$1 device=$2

	set-serial_number $device
	local rule
	printf -v rule "$rule_format" $serial_number $name
	echo "$rule"
}


# ----------------------------------------------------------------------------
# funcctions for action 'init'
# ----------------------------------------------------------------------------

init-device() {
	local name=$1 device=$2

	raw_device=$device
	mount_dir=$(snapback drive $name)
	set-mount_dir-FS_label-raw_device
	device=$raw_device
	[[ -b $device ]] || abort-function "$device not a block device"

	fuser -m -v $device && $IfRun abort "$device is in-use"
	[[ -s $drive_key_file ]] || abort "must create $drive_key_file"

	warn "encrypting $device\n\n   be SURE you type 'YES' not 'yes' ..."
	local \
	LUKS2_opts="--type luks2 --sector-size $sector_size --label $FS_label"
	$IfRun sudo cryptsetup luksFormat $LUKS2_opts $device $drive_key_file||
	    abort-function "cryptsetup returned $?; maybe repeat, after run:
		sudo cryptsetup close $FS_label"

	set-decrypted_device 		# also decrypts
	local dev=$decrypted_device
	warn "decrypting $device, so you can run: snapback mkfs $dev $name

	add rule to $config_dir/drives.rules for $*"
}

# ----------------------------------------------------------------------------
# functions for action 'open'
# ----------------------------------------------------------------------------

open-all-unopened-drives() {

	$our_path list-drives |
	while read dev decrypts to drive drive_name
	   do	df --output=target --no-sync -x devtmpfs -x tmpfs |
		   grep -q "${drive_dir_prefix-\b}$drive_name$" && continue
		$_our_name $our_opts open $dev $drive_name
	done
}

# ------------------------------------------------------------------

set-mount_dir-FS_label-raw_device() {

	[[ $mount_dir == /* ]] || mount_dir=$(snapback drive $mount_dir)
	[[ $mount_dir ]] || exit 1

	set-FS_label--from-mount_dir $mount_dir

	[[ $raw_device ]] || return

	local LUKS_device=
	[[ $raw_device == /dev/*  ]] || raw_device=/dev/$raw_device
	for raw_device in $raw_device*
	    do	sudo cryptsetup isLuks $raw_device || continue
		LUKS_device=$raw_device
		break
	done
	raw_device=$LUKS_device
	[[ -b $raw_device ]] || abort "$raw_device is not a block device"
}

# ---------------------------------

setup-vars-for-log-and-abort() {

	file_for_logging=$log_dir/$FS_label.log
	log_msg_prefix=' $raw_device'

	[[ -t 0 || -t 1 || -t 2 || ${HOME-} ]] || exec 2> $file_for_logging
}

# ---------------------------------

set-decrypted_device() {

	decrypted_device=/dev/mapper/$FS_label

	[[ -b $decrypted_device ]] ||
	$IfRun sudo cryptsetup open \
	   --key-file $drive_key_file --type luks $raw_device $FS_label ||
		abort "'cryptsetup open' failed, status=$?; check syslog, and see D. in snapback's doc/Install.txt"

	[[ -b $decrypted_device ]] || $IfRun \
	    abort "opened encrypted device, but can't find $decrypted_device"
}

# ---------------------------------

set-log_device-mount_options() {
	local FS_type=$1

	log_device=
	mount_options=${common_mount_options:-nosuid,nodev,noatime}

	local FS_opts=		   # grab opts from /etc/snapback/configure.sh
	case $FS_type in
	    ( ext[1-3] ) FS_opts=${extN_mount_options-} ;;
	    ( ext[4-9] ) FS_opts=${extN_mount_options:-journal_checksum} ;;
	    ( xfs )	 FS_opts=${xfs_mount_options:-logbsize=256k}
			 set -- /dev/mapper/*${FS_label}_log
			 [[ -b $1 ]] && log_device=$1 FS_opts+=",logdev=$1" ;;
	    ( * ) abort "don't know how to mount filesystem of type '$FS_type'"
	esac
	[[ $FS_opts ]] && mount_options+=",$FS_opts"
}

# ---------------------------------

open() {
	local mount_dir=$1 raw_device=${2-}

	set-mount_dir-FS_label-raw_device

	is-an-FS-device-mounted $mount_dir && abort "$mount_dir has an FS"

	setup-vars-for-log-and-abort

	set-decrypted_device		# also decrypts

	[[ $do_mount ]] || return 0

	RunCmd sudo mkdir -p $mount_dir

	set-FS_type--from-path $decrypted_device
	set-log_device-mount_options $FS_type

	while [[ $log_device && ! -b $log_device ]]
	   do	[[ -t 1 ]] && echo "Waiting for log $log_device to appear"
		sleep 1
	done
	[[ $do_mount_RO ]] && mount_options+=,ro
	RunCmd sudo \
	mount -t $FS_type -o $mount_options $decrypted_device $mount_dir
}

# ----------------------------------------------------------------------------
# funcctions for action 'close'
# ----------------------------------------------------------------------------

close-all-opened-drives() {
	
	[[ ${drive_dir_prefix-} ]] || 
	    abort-function "only works when using snapback"

	df --output=target --no-sync -x devtmpfs -x tmpfs |
	   grep "^$drive_dir_prefix" |
	while read mount_point
	   do	$_our_name $our_opts close -q $mount_point
	done
}

# ----------------------------------------------------------------------------

set-mount_dir() {
	local _mount_dir=$1
	mount_dir=$_mount_dir

	case $mount_dir in
	    ( /*  ) ;;
	    ( max ) mount_dir=$(snapback max-drive) ;;
	    (  *  ) mount_dir=$(snapback     drive $mount_dir) ;;
	esac

	[[ $mount_dir && -d $mount_dir ]] || 
	    abort "can't find mount directory for '$_mount_dir'"
}

# ---------------------------------

set-name--from-FS_label() {
	local FS_label=$1

	[[ -b /dev/mapper/$FS_label ]] && name=$FS_label && return

	local prefix
	for prefix in ${old_crypt_name_prefixes-}
	    do	name=$prefix$drive_name
		[[ -b /dev/mapper/$name ]] && break
		name=
	done
	[[ $FS_label == backup_Z ]] && name=$FS_label # for testing

	[[ ${name-} ]]
}

# ---------------------------------

assert-drive-has-new-backups() {
	local mount_dir=$1

	[[ ${do_force-} || ! $(which snapback) ]] ||
	snapback has-new-snapshots $mount_dir && return

	warn "use -f to force a close"
	exit 1
}

# ---------------------------------
	
unmount-drive() {
	local mount_dir=$1

	echo "unmounting $mount_dir, can take minutes ..."

	[[ $debug_opt ]] ||
	    { snapback $our_opts umount $drive &> /dev/null && return; }

	is-an-FS-device-mounted $mount_dir || return

	$IfRun sudo umount $mount_dir
	local status=$?
	if [[ $status != 0 ]]
	   then echo -e "\numount failed with status=$status"
		cmd="fuser -mv $mount_dir |& sort -k4"
		echo -e "\n==> $cmd <==\n"
		eval "sudo $cmd" | fgrep -v -e ' kernel mount '
		echo -e "\nTo kill processes: sudo fuser -k -9 -M $mount_dir\n"
		exit $status
	fi
}

# ----------------------

set-raw_device--from-drive_name() {

	warn "need to finish $FUNCNAME, use: sudo cryptsetup status"
	raw_device=
}

# ---------------------------------

unmap-drive() {
	local name=$1

	echo "unmapping ${mount_dir-} (assuming name=$name) ..."
	RunCmd sudo cryptsetup close $name && echo "Success!"
}

# ---------------------------------

park-disk-heads() {
	local raw_device=$(basename $1)

	$IfRun sudo bash -c "echo 1 > /sys/block/$raw_device/device/delete"
}

# ----------------------

alert-smartd() {

	$IfRun sudo killall -1 smartd 2> /dev/null # so it notices lost drive
}

# ---------------------------------

close() {
	[[ $1 == -q ]] && { local is_quiet=$true; shift; } || local is_quiet=

	set-mount_dir $1

	set-FS_label--from-mount_dir $mount_dir

	setup-vars-for-log-and-abort

	if ! set-name--from-FS_label $FS_label
	   then [[ $is_quiet ]] && return
		abort "can't find encryption 'name' for $FS_label"
	fi

	assert-drive-has-new-backups $mount_dir

	unmount-drive $mount_dir

	set-raw_device--from-drive_name $name
	unmap-drive $name

	[[ $action == close && $raw_device ]] || return

	park-disk-heads $raw_device && alert-smartd
}

# ----------------------------------------------------------------------------

show-status() {
	local name=$1

	set-mount_dir $1

	set-FS_label--from-mount_dir $mount_dir

	sudo cryptsetup status $FS_label
}

##############################################################################
# main
##############################################################################

[[ $# != 0 ]] || abort "specify an action to perform\n$Usage"

action=$1; shift
_our_name="$our_name"
 our_name="$our_name $action"
undo_action_abbrev() { action=$1 our_name="$_our_name $1" ; }

# ---------------------------------

process_action() {

stack_frame_to_show=0		# show line-number inside the 'case' statement

$Trace

case $action in
   # list-drives: show all encrypted drives.
   ( l*s* ) undo_action_abbrev list-drives # ls
	list-drives "$@"
	;;
   # status name: show detailed status of encrypted drive.
   ( s* ) undo_action_abbrev status
	[[ $# == 1 ]] || abort-with-action-Usage
	show-status "$@"
	;;
   # init name device: setup encryption (find device with: ls -lt /dev/sd*)-
   ( init )
	[[ $1 == -s ]] && { sector_size=$2; shift 2; } || sector_size=4096
	[[ $# == 2 ]] || abort-with-action-Usage
	init-device "$@"
	;;
   # rule name device: print a udevd rule to open the device
   ( r* ) undo_action_abbrev rule
	[[ $# == 2 ]] || abort-with-action-Usage
	print-rule "$@"
	;;
    # open [-M] { mount-dir device | all }: run 'cryptsetup open' on device,
    ( o* ) undo_action_abbrev open
	[[ ${1-} = -r ]] && { shift; do_mount_RO=$true; } || do_mount_RO=$false
	[[ ${1-} = -M ]] && { shift; do_mount=$false  ; } || do_mount=$true
	if [[ $* == all ]]
	   then open-all-unopened-drives
	elif [[ $# == [12] ]]
	   then open "$@"
	   else abort-with-action-Usage
	fi
	;;
    # close [-f] {mount-dir|all}: unmap drive (cryptsetup close) & park heads.
    # unmap [-f] {mount-dir|all}: like 'close', but don't park disk heads.
    ( c* | u* )
	if [[ $action == c* ]]
	   then undo_action_abbrev close
	   else undo_action_abbrev unmap
	fi
	[[ ${1-} == -f ]] && { shift; do_force=$true; } || do_force=$false
	if [[ $* == all ]]
	   then close-all-opened-drives
	elif [[ $# == [12] ]]
	   then close "$@"
	   else abort-with-action-Usage
	fi
	;;
   ( * )
	warn "'$action' is not a recognized action, run: $_our_name -h"; exit 1
	;;
esac
}

process_action "$@"
